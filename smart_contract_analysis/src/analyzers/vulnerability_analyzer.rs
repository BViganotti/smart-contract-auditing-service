use solang_parser::pt::*;
use std::error::Error;
use crate::Vulnerability;

pub trait VulnerabilityAnalyzer {
    fn name(&self) -> &'static str;
    fn description(&self) -> &'static str;
    
    fn analyze(&mut self, unit: &SourceUnit) -> Result<Vec<Vulnerability>, Box<dyn Error>>;
    
    fn analyze_contract(&mut self, contract: &ContractDefinition) -> Result<Vec<Vulnerability>, Box<dyn Error>> {
        Ok(Vec::new())
    }
    
    fn analyze_function(&mut self, func: &FunctionDefinition) -> Result<Vec<Vulnerability>, Box<dyn Error>> {
        Ok(Vec::new())
    }
    
    fn analyze_statement(&mut self, stmt: &Statement) -> Result<Vec<Vulnerability>, Box<dyn Error>> {
        Ok(Vec::new())
    }
    
    fn analyze_expression(&mut self, expr: &Expression) -> Result<Vec<Vulnerability>, Box<dyn Error>> {
        Ok(Vec::new())
    }

    fn is_critical(&self, vulnerability: &Vulnerability) -> bool {
        vulnerability.severity == "Critical" || vulnerability.severity == "High"
    }

    fn merge_vulnerabilities(&self, mut vulns: Vec<Vulnerability>) -> Vec<Vulnerability> {
        vulns.sort_by(|a, b| {
            if self.is_critical(a) && !self.is_critical(b) {
                std::cmp::Ordering::Less
            } else if !self.is_critical(a) && self.is_critical(b) {
                std::cmp::Ordering::Greater
            } else {
                a.severity.cmp(&b.severity)
            }
        });
        vulns
    }
}

pub struct AnalysisContext {
    pub has_external_call: bool,
    pub has_state_change: bool,
    pub has_validation: bool,
    pub has_critical_operation: bool,
    pub uses_unsafe_operation: bool,
}

impl Default for AnalysisContext {
    fn default() -> Self {
        Self {
            has_external_call: false,
            has_state_change: false,
            has_validation: false,
            has_critical_operation: false,
            uses_unsafe_operation: false,
        }
    }
}
